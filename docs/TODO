TODO
----
        make all test cases work again

        rewrite / redo complation process / use autoconfiguration


	tree's should return iterator to search results, not single result !!
	(when getting multiple results, easy to implement)

trees seem to be working ok.
        write strength test for trees:
          use lots of random inserts and deletions and check tree always
          contains all correct data and doesn't have already
          removed data.
          check size() of tree is correct
          check height of tree is always within guaranteed limits.
             (check trees cannot degenerate - check avl tree will be
              avl tree all a time, check red black tree will has max
              2*height of perfect binary tree)
	
	merge dlib_global::DALL (optimizations) and cis_algos::dynamic_array

	string matching
 	linked list search algorithms
	hash tables
	advanced trees: (interval), optimum, multivariable/branch with hash
                        stages

	graph algorithms
	
	documentation

	digital signal processing
		fft and ifft (generalization not done)
		wavelets (fast discrete wavelets)
		spectrum estimation (hamming etc.)
		filtering (fir filters: wiener, adaptive - look at 'silence' code)
		EQ
	digital image processing:
		extend 1d signal processing to 2d

	documentation
	
	merge with OpenGL code (graffa code). (when CORBA NDI works = CNDI)

	merge with 'dlib', make shared/loadable drivers really work merge
	this with CNDI to get generic "hot pluggable service objects".

		
	ODE solving
	computational geometry
	statistics
   
 
 - parsing & compiler
 - basic data compression: huffman, lossy compression: cos-based (aka like in jpg.) or
   game-of-life kind of thing which I don't know but have document about: better than jpg
   but patented (as well as jpg) or principal component analysis and remove components
   which don't have much 'power'.
 
 

 learn its theory first. after those one locks, semaphores in C++
 (use posix/etc. implementation just create wrappers) after these

 ones create basic networking: check out the old HTML server code.
  - then statistical functions, find out which is best way to get implementation of
	   regular expressions -> statistical natural language processing:
	   
   1) -> try to use stat. NLP to create intelligent mail filter which learn by example /
         learns when user corrects that filter has filtered mail to wrong folder abd moves it
	 to another one.	

==============================
 - do DSP system for x86 architechtures: used as a audio sunthesizer
	(analog basic 1st then more complex sound synthesizing effects).
  (x86 is terrible for DSP but everyone has one) -> if time/money/interest:
   product: much like Generator. idea: non-linear/maybe NN based sound synthesis
   could be great, make
   NN learn changes in other parameters: 'one button technology': use NN
   to control/learn parameters
   for sound synthesis for certain kind of sound etc. -- think about this more).
   
 - statistical stock values analysis (ICA? - learn it this summer) (learn about it more) + 
   NN time-series analysis/estimation:
   -> try: 'find and use/buy only most predictable stocks' - strategy and
   try 'metalevel NN that tries to learn how good primary NN is'-idea.
 
 - find out some logic program + think about rule extraction from NN
   (find out old notes about it)
  -> logical rules and new rules creation using logic / NN-extracted rules
     verification using logic
	
 - learn UI system that can be used with C++ and that supports Linux&Windows 
   -> (there was/is one (or more) but I can't remember it). 
   
 - check out DB systems, how they work etc.. (maybe)
   
 
===============
WHEN BASIC ALGORITHMS AND UI CODE IS DONE:

 - these will beta test produced code and
   be candidates for further developement (1 MONTH??)

-> some 'office' program for unix which exists under Windows but doesn't exist for Unix
-> natural language filter
-> sound synthesis [ALSA / windows], audio processing, sequenzer software
-> NN time-series analysis

-> small-scale game: - use old, already avaible code
-> program that collects computer usage statistics/information about computer usage (details)
   -> better understanding of user
-> 3d engine












      
   